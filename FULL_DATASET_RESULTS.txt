═══════════════════════════════════════════════════════════════════
AIR QUALITY PROJECT - FULL DATASET BENCHMARK RESULTS
═══════════════════════════════════════════════════════════════════

Dataset: 2,334,535 records from 517 CSV files
Stations: 1,417 unique monitoring stations  
Time Period: August 10 - September 24, 2020 (516 hourly time slots)
Hardware: ARM64 macOS, 8 OpenMP threads
Date Run: $(date)

═══════════════════════════════════════════════════════════════════
QUERY PERFORMANCE COMPARISON
═══════════════════════════════════════════════════════════════════

Query 1: Average PM2.5 at Specific Time
─────────────────────────────────────────
Row Model (Serial):     7,493.75 µs
Row Model (Parallel):   5,200.33 µs  →  1.44x speedup
Column Model (Serial):     21.71 µs
Column Model (Parallel):   72.83 µs  →  0.30x (overhead)

Winner: Column Model 71x FASTER than Row (parallel)

Key Insight: Column model accesses one time slot (~4,500 records),
while row model must scan ALL 1,417 stations!


Query 2: Station Time Series (50 measurements)
────────────────────────────────────────────────
Row Model:        0.29 µs
Column Model: 28,027.50 µs

Winner: Row Model 96,000x FASTER than Column!

Key Insight: Row model has direct station access (one lookup),
while column model must scan ALL 516 time slots!


Query 3: Top-10 Stations by Pollution Level
─────────────────────────────────────────────
Row Model (Serial):     7,295.75 µs
Row Model (Parallel):   7,492.96 µs  →  0.97x (overhead)
Column Model (Serial):    144.21 µs
Column Model (Parallel):   80.50 µs  →  1.79x speedup

Winner: Column Model 93x FASTER than Row (parallel)

Key Insight: Column's direct time access + parallel sorting dominates.


File Loading (517 files)
─────────────────────────
Sequential:   11,144.8 ms  (11.1 seconds)
Parallel:     22,387.3 ms  (22.4 seconds)

Winner: Sequential 2x FASTER

Key Insight: Fast SSD + OS caching optimized for sequential reads.
Parallel would likely win on HDD or network storage.

═══════════════════════════════════════════════════════════════════
KEY FINDINGS
═══════════════════════════════════════════════════════════════════

1. DATA STRUCTURE MATTERS MORE THAN PARALLELIZATION!
   - 96,000x difference based purely on memory layout
   - Not about cores, threads, or optimization tricks
   - Fundamental architectural decision

2. SCALE REVEALS TRUE PATTERNS
   - Small dataset (26K): Column 2.8x faster
   - Large dataset (2.3M): Column 71x faster
   - Differences amplify with data volume

3. OPENMP BENEFITS VARY BY QUERY
   - Row temporal: 1.44x speedup (scan many stations)
   - Column top-N: 1.79x speedup (sort + filter)
   - Small operations: overhead dominates

4. CHOOSE DATA STRUCTURE FOR YOUR QUERIES
   - OLAP (analytics): Use column-oriented
   - OLTP (transactions): Use row-oriented
   - Mixed workload: Consider hybrid or separate stores

═══════════════════════════════════════════════════════════════════
CONCLUSION
═══════════════════════════════════════════════════════════════════

Successfully demonstrated that DATA STRUCTURE CHOICE has orders of
magnitude more impact than parallelization alone. At 2.3M records:

✅ Column model: 71-93x faster for cross-station analytics
✅ Row model: 96,000x faster for per-station queries  
✅ OpenMP: 1.4-1.8x speedup where applicable
✅ Architecture: Proven scalable and correct

This is why real databases use different engines for OLTP vs OLAP!

═══════════════════════════════════════════════════════════════════
